#!/usr/bin/env python3

"""pylunarvim

    Python file setter.

    This script allows the user to create a file with the python shebang:
    #!/usr/bin/env python3 line, and gives execute permissions for the users
    creator. Ready to code!? Then you can run your python file like this:
        ./foo. Without the .py extension.

    This script needs you to pass a file name. Like this: script.py or script.
    Works with both. And should be used like this: lvimpy --file script.
    Alternatively you can add an alias in bashrc or zshrc, depending on your
    Linux "shell" (bash or zsh), like this:
        alias lp='lvimpy --file'. So you can use this way: lp script

    You don't need to install any modules for this script to work.
"""

import argparse
from argparse import Namespace
import os
import stat
from pathlib import Path
import subprocess
import sys
from Settings import Settings


shebang = "#!/usr/bin/env python3"


def set_shebang(user_shebang: str) -> None:
    """Sets shebang on config file, for later read

    :param shebang: shabang to set on config file
    :type: str
    :returns: No return
    :rtype: None
    """

    with open('~/pylunarvim/shebang.cfg', "a") as config:
        config.write(shebang)


def source_zshrc() -> None:
    """Sources ~/.zshrc for the PATH variable to work

    :param:
    :type:
    :returns: No return
    :rtype: None
    """

    # TODO: Check if the subrocess.run returns a value. In a failure,
    # must print a message.

    subprocess.run(["source", '~/.zshrc'])


def check_shebang(file_path: str) -> bool:
    """Gets file path and checks shebang on the first line in file

    :param file_doc: The path for for the file to check
    :type file_path: str
    :returns: True if shebang written in file, otherwise False
    :rtype: bool
    """

    try:
        with open(file_path, "r") as input_file:
            line = input_file.readline()
            if line == shebang:
                return True
    except IsADirectoryError as dir:
        file_path_list = file_path.split("/")
        file = file_path_list[-1]
        print(f"{file}: {dir.strerror}")

    return False


def edit(file_path: str) -> None:
    """Enters editor on file location read from file_path
    argument

    :param file_path: The path for the file to edit
    :type file_path: str
    :returns: No return
    :rtype: None
    """

    path = Path(file_path)
    if not path.is_dir():
        subprocess.run(["lvim", file_path])


def rename(file_path: str) -> None:
    """Gets file path to get the file to rename

    :param file_path: The path for the file to rename
    :type file_path: str
    :returns: No return
    :rtype: None
    """

    if file_path.endswith(".py"):
        current_file_path = file_path
        new_file_path = Path(current_file_path).with_suffix('')  # cuts out .py
        subprocess.run(["mv", current_file_path, str(new_file_path)])


def get_arguments() -> Namespace:
    """Gets the arguments from command line, it parsers them

    :param: No arguments
    :type:
    :returns: Returns a string argument for the name of the dir
    :rtype: str
    """

    parser = argparse.ArgumentParser(
        prog="pylunarvim",
        description=(
            "Creates a file with exec rights for the owner and, "
            "and writes a python shebang at the beginning of "
            "the the file."),
        epilog="Thanks for using %(prog)s! :)")

    parser.add_argument('--getworkplace', nargs='?', const=True,
                        type=bool, default=True)
    parser.add_argument("--setworkplace", type=str)
    parser.add_argument("--file", type=str)

    args: Namespace = parser.parse_args()

    if not args.file:
        parser.print_help()
        parser.exit()

    return args


def give_permissions(python_file: bool, file_path: str) -> None:
    """If it's a python file, then gives exec flags on file for the user that
    creates it

    :param python_file: Flag to know if it's a python file
    :type python_file: bool
    :param file_path: File path for the file to change its exec mode
    :type file_path: str
    :returns: No return
    :rtype: None
    """

    if python_file and file_path:
        os.chmod(file_path, stat.S_IXUSR | stat.S_IRUSR | stat.S_IRWXU)


def touch(file_path: str) -> None:
    """Gets file path and touches it. If the does not exist, it creates it

    :param ile_path: File path for the file to create or touch
    :type file_path: str
    :returns: No return
    :rtype: None
    """

    Path(file_path).touch()


def shebang_write(file_path: str) -> None:
    """Gets file path, searches it for the files at the end of the path and
    writes a sheband in it

    :param file_path: File path for the file to open for writing shebang
    :type file_path: str
    :returns: No return
    :rtype: None
    """

    if os.stat(file_path).st_size == 0:
        with open(file_path, "w+") as file:
            file.write(shebang)


def runner() -> None:
    """Executes all the processes to acomplish the task of creating a file with
    a shenbang on it and give execution permissions to file's owner

    :param:
    :type:
    :returns: No return
    :rtype: None
    """

    args: Namespace = get_arguments()

    settings = Settings()
    settings.display_work_place(args.getworkplace)

    if not settings.check_work_place(args.getworkplace):
        sys.exit(1)
    else:
        settings.set_work_place(args.setworkplace)
        work_place = settings.get_work_place_settings()

        file_path = work_place + args.file

        touch(file_path)
        shebang_write(file_path)
        line_there: bool = check_shebang(file_path)
        give_permissions(line_there, file_path)
        rename(file_path)
        edit(file_path)


if __name__ == "__main__":
    runner()
