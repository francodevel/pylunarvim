#!/usr/bin/env python3

"""Python file setter.

    This script allows the user to create a file with the python shebang:
    #!/usr/bin/env python3 line, and gives execute permissions for the users
    creator. Ready to code!? Then you can run your python file like this:
        ./foo. Without the .py extension.

    This script needs you to pass a file name. Like this: script.py or script.
    Works with both. And should be used like this: lvimpy --file script.
    Alternatively you can add an alias in bashrc or zshrc, depending on your
    Linux "shell" (bash or ksh), like this:
        alias lp='lvimpy --file'. So you can use this way: lp script

    You don't need to install any modules for this script to work.
"""

import argparse
from argparse import Namespace
import os
import stat
from pathlib import Path
import subprocess
import sys

default_shebang = "#!/usr/bin/env python3"


def set_shebang(shebang: str) -> None:
    """Sets shebang on config file, for later read.

    :params shebang: The shabang to set
    :type: str
    :returns: No return
    :rtype: None
    """

    with open('~/pylunarvim/shebang.txt', "a") as config_file:
        config_file.write(shebang)


def check_shebang(file_path: str) -> bool:
    """Gets file path and checks shebang on the first line in file

    :param file_doc: The path for for the file to check
    :type file_path: str
    :returns: True if shebang written in file, otherwise False
    :rtype: bool
    """

    try:
        with open(file_path, "r") as input_file:
            line = input_file.readline()
            if line == default_shebang:
                return True
    except IsADirectoryError as dir:
        file_path_list = file_path.split("/")
        file = file_path_list[-1]
        print(f"{file}: {dir.strerror}")

    return False


def edit(file_path: str) -> None:
    """Enters editor on file location read from file_path
    argument

    :param file_path: The path for the file to edit
    :type file_path: str
    :returns: No return
    :rtype: None
    """

    path = Path(file_path)
    if not path.is_dir():
        subprocess.run(["lvim", file_path])


def rename(file_path: str) -> None:
    """Gets file path to get the file to rename

    :param file_path: The path for the file to rename
    :type file_path: str
    :returns: No return
    :rtype: None
    """

    if file_path.endswith(".py"):
        current_file_path = file_path
        new_file_path = Path(current_file_path).with_suffix('')  # cuts out .py
        subprocess.run(["mv", current_file_path, str(new_file_path)])


def get_arguments() -> Namespace:
    """Gets the arguments from command line, it parsers them

    :param: No arguments
    :type:
    :returns: Returns a string argument for the name of the dir.
    :rtype: str
    """

    parser = argparse.ArgumentParser(
        prog="pylunarvim",
        description=(
            "Creates a file with exec rights for the owner and, "
            "and writes a python shebang at the beginning of "
            "the the file."),
        epilog="Thanks for using %(prog)s! :)")

    parser.add_argument('--getworkplace', nargs='?', const=True,
                        type=bool, default=True)
    parser.add_argument("--setworkplace", type=str)
    parser.add_argument("--file", type=str)

    args: Namespace = parser.parse_args()

    if not args.file:
        parser.print_help()
        parser.exit()

    return args


def give_permissions(python_file: bool, file_path: str) -> None:
    """If it's a python file, then gives exec flags on file for the user that
    creates it

    :param python_file: Flag to know if it's a python file
    :type python_file: bool
    :param file_path: File path for the file to change its exec mode
    :type file_path: str
    :returns: No return
    :rtype: None
    """

    if python_file and file_path:
        os.chmod(file_path, stat.S_IXUSR | stat.S_IRUSR | stat.S_IRWXU)


def touch(file_path: str) -> None:
    """Gets file path and touches it. If the does not exist, it creates it

    :param ile_path: File path for the file to create or touch
    :type file_path: str
    :returns: No return
    :rtype: None
    """

    Path(file_path).touch()


def shebang_write(file_path: str) -> None:
    """Gets file path, searches it for the files at the end of the path and
    writes a sheband in it

    :param file_path: File path for the file to open for writing shebang
    :type file_path: str
    :returns: No return
    :rtype: None
    """

    if os.stat(file_path).st_size == 0:
        with open(file_path, "w+") as file:
            file.write(default_shebang)


def work_place_exists(work_place: str) -> bool:
    """Gets file argument in file_arg variable, and locates it on file system,
    then return the full path where is located.

    :param file_arg: Relative file path argument to locate
    :type file_arg: str
    :returns: str with the full path of the located file
    :rtype: str
    """

    path = Path(work_place)
    if path.exists() and path.is_dir():
        return True
    else:
        return False


def set_work_place(work_place: str):
    """Writes work place on a config file for later read.

    :param work_place: Path to the existing work place
    :type work_place: str
    :returns: No return
    :rtype: None
    """

    if not work_place_exists(work_place):
        os.makedirs(work_place)
    with open("~/pylunarvim/config.txt", "w") as config:
        config.write(work_place)


def get_work_place_settings() -> str:
    """Gets working space set by the user, the returns it

    :param: No arguments
    :type:
    :returns: str with the path for the working space set by user on config.txt
    :rtype: str
    """

    with open("~/pylunarvim/config.txt", "r") as config:
        work_place = config.readline()

    return work_place


def check_work_place(work_place_path: str) -> bool:
    """Check if work place on work_place_path exists, if so, then returns True.
    If not, then returns False

    :params work_place_path: Work place path to check
    :type: str
    :returns: bool signaling that the work place is present or not
    :rtype: bool
    """

    try:
        if work_place_exists(work_place_path):
            return True
        else:
            raise Exception

    except Exception:
        print("ERROR: Path to Work Place Not Found")
        return False


def display_work_place(getworkplace: bool) -> None:
    """Reads work place settings from file.

    :params getworkplace: False or True for displaying or not the settings
    :type: bool
    :returns: No return
    :rtype: None
    """

    if getworkplace:
        work_place_settings = get_work_place_settings()
        print(work_place_settings)
        sys.exit(0)


def add_work_place_to_path(work_place: str) -> None:
    """Adds work_place to the PATH variable

    :params work_place: str with the path to work_place
    :type: str
    :returns: No return
    :rtype: None
    """

    home = Path.home()
    with open(str(home) + ".zshrc", "a") as zshrc_file:
        zshrc_file.write("")
        zshrc_file.write(f'export PATH={work_place}:$PATH')


def run() -> None:
    """Executes all the processes to acomplish the task of creating a file with
    a shenbang on it and give execution permissions to file's owner

    :params:
    :type:
    :returns: No return
    :rtype: None
    """

    args: Namespace = get_arguments()

    display_work_place(args.getworkplace)

    if not check_work_place(args.getworkplace):
        sys.exit(1)
    else:
        set_work_place(args.setworkplace)
        work_place = get_work_place_settings()

        file_path = work_place + args.file

        touch(file_path)
        shebang_write(file_path)
        line_there: bool = check_shebang(file_path)
        give_permissions(line_there, file_path)
        rename(file_path)
        editor(file_path)


if __name__ == "__main__":
    run()
