#!/usr/bin/env python3

"""Python file setter.

    This script allows the user to create a file with the python shebang:
    #!/usr/bin/env python3 line, and gives execute permissions for the users
    creator. Ready to code!? Then you can run your python file like this:
        ./foo. Without the .py extension.

    This script needs you to pass a file name. Like this: script.py or script.
    Works with both. And should be used like this: lvimpy --file script.
    Alternatively you can add an alias in bashrc or zshrc, depending on your
    Linux "shell" (bash or ksh), like this:
        alias lp='lvimpy --file'. So you can use this way: lp script

    You don't need to install any modules for this script to work.
"""

import argparse
from argparse import Namespace
import os
import stat
from pathlib import Path
import subprocess
import sys

shebang = "#!/usr/bin/env python3"


def check_shebang(file_path: str) -> bool:
    """Gets file path and checks shebang on the first line in file

    :param file_doc: The path for for the file to check
    :type file_path: str
    :returns: True if shebang written in file, otherwise False
    :rtype: bool
    """

    try:
        with open(file_path, "r") as input_file:
            line = input_file.readline()
            if line == shebang:
                return True
    except IsADirectoryError as dir:
        file_path_list = file_path.split("/")
        file = file_path_list[-1]
        print(f"{file}: {dir.strerror}")

    return False


def lvim_editor(file_path):
    """Gets file path to open it with lvim (Lunar Vim)

    :param file_path: The path for the file to open with lvim
    :type file_path: str
    :returns: None, it returns nothing
    :rtype: None
    """

    path = Path(file_path)
    if not path.is_dir():
        subprocess.run(["lvim", file_path])


def rename(file_path):
    """Gets file path to get the file to rename

    :param file_path: The path for the file to rename
    :type file_path: str
    :returns: None, it returns nothing
    :rtype: None
    """

    if file_path.endswith(".py"):
        file_path = Path(file_path)
        file_without_suffix = file_path.with_suffix('')
        subprocess.run(["mv", file_path, file_without_suffix])


def get_arguments() -> Namespace:
    """Gets the arguments from command line, it parsers them

    :param: Gets no arguments
    :type void
    :returns: Returns a string argument for the name of the dir.
    :rtype: str
    """

    parser = argparse.ArgumentParser(
        prog="pylunarvim",
        description=(
            "Creates a file with exec rights for the owner and, "
            "and writes a python shebang at the beginning of "
            "the the file."),
        epilog="Thanks for using %(prog)s! :)")
    parser.add_argument("--work_place", type=str)
    parser.add_argument("--file", type=str)
    args: Namespace = parser.parse_args()

    if not args.file:
        parser.print_help()
        parser.exit()

    return args


def give_permissions(python_file: bool, file_path: str) -> None:
    """If it's a python file, then gives exec flags on file for the user that
    creates it

    :param python_file: Flag to know if it's a python file
    :type python_file: bool
    :param file_path: File path for the file to change its exec mode
    :type file_path: str
    :returns: None, it returns nothing
    :rtype: None
    """

    if python_file and file_path:
        os.chmod(file_path, stat.S_IXUSR | stat.S_IRUSR | stat.S_IRWXU)


def touch(file_path):
    """Gets file path and touches it. If the does not exist, it creates it

    :param ile_path: File path for the file to create or touch
    :type file_path: str
    :returns: None, it returns nothing
    :rtype: None
    """

    Path(file_path).touch()


def shebang_write(file_path: str):
    """Gets file path, searches it for the files at the end of the path and
    writes a sheband in it

    :param file_path: File path for the file to open for writing shebang
    :type file_path: str
    :returns: None, it returns nothing
    :rtype: None
    """

    if os.stat(file_path).st_size == 0:
        with open(file_path, "w+") as out_file:
            out_file.write(shebang)


def work_place_exists(work_place: str) -> bool:
    """Gets file argument in file_arg variable, and locates it on file system,
    then return the full path where is located.

    :param file_arg: Relative file path argument to locate
    :type file_arg: str
    :returns: str with the full path of the located file
    :rtype: str
    """

    path = Path(work_place)
    if path.exists() and path.is_dir():
        return True
    else:
        return False


def set_working_space(folder_path: str):
    with open("~/pylunarvim/config.txt", "w") as config:
        config.write(folder_path)


def get_working_space() -> str:
    """Gets working space set by the user, the returns it

    :param void
    :type void, no arguments are given
    :returns: str with the path for the working space set by user on config.txt
    :rtype: str
    """

    with open("~/pylunarvim/config.txt", "r") as config:
        work_place = config.readline()

    return work_place


def check_work_place(folder_path: str) -> bool:
    try:
        if work_place_exists(folder_path):
            return True
        else:
            raise Exception

    except Exception:
        print("ERROR: Path to File Not Found")
        return False


def run() -> None:
    """Executes all the processes to acomplish the task of creating a file with
    a shenbang on it and give execution permissions to file's owner

    :param void
    :type void, no arguments are given
    :returns: None, it returns nothing
    :rtype: None
    """

    # print(locate_file("mypy_test.py"))  # DEBUG

    args: Namespace = get_arguments()

    if not check_work_place(args.work_place):
        sys.exit(1)
    else:
        set_working_space(args.work_place)
        work_place = get_working_space()

        file_path = work_place + args.file

        touch(file_path)
        shebang_write(file_path)
        line_there: bool = check_shebang(file_path)
        give_permissions(line_there, file_path)
        rename(file_path)
        lvim_editor(file_path)


if __name__ == "__main__":
    run()
